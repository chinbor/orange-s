## orange's 第四章学习笔记

### 一. 突破512字节的限制

> #### 一个操作系统从开机到开始运行，大致经历“引导-&gt;加载内核入内存-&gt;跳入保护模式-&gt;开始执行内核”,在内核开始执行之前不但要加载内核，而且还有准备保护模式等一系列工作，由于这一系列工作有点大，引导扇区的512字节可能不够用，所以可以将这个过程交给一个loader模块来做，引导程序就只需要将loader加载如内存，然后控制权给它，其他工作就由loader来做

### 二. FAT12

> #### FAT12是DOS时代就开始使用的文件系统\(File System\)，直到现在仍然在软盘上使用，FAT12软盘被格式化后为：有两个磁头，每个磁头80个柱面（磁道），每个柱面有18个扇区，每个扇区512个字节空间。所以标准软盘的总空间为
>
> #### 2 \* 80 \*18 \* 512=1474560B=1440K=1.44m
>
> #### 下面是FAT12的结构图：
>
> ![](http://hi.csdn.net/attachment/201202/22/0_1329914901XICx.gif)
>
> #### 1、引导扇区
>
> #### 操作系统之所以认识FAT12格式的磁盘，其秘密就在于逻辑0扇区这512B上。如果这512字节的最后两个字节的内容分别是55和AA（0xAA55低字节在前，高字节在后\)的话，BIOS在启动时会将这个扇区读取到0:7C00h-0:7DFFh处，然后跳转到0:7C00h处继续执行指令，操作系统即用此来达到引导系统的目的，而这个磁盘就称为引导磁盘。
>
> #### 操作系统标识FAT12文件系统是因为在逻辑0扇区\(即引导扇区\)处还存储着一个特定的数据结构，此结构有固定的格式，在操作系统将此磁盘格式化时自动生成，具体数据结构如下表所示：
>
> ![](/assets/QQ图片20190503190103.png)下面我们介绍其中的一些变量的含义：
>
> BS\_jmpBoot：是跳转指令，偏移0处的跳转指令必须是合法的可执行的基于x86的CPU指令，如：jmp start，这样可以生成3字节长的指令，（加关键字short的短跳转指令的长度是2字节），指向操作系统引导代码部分。Windows和MS-DOS生成的FAT12启动扇区中的跳转指令是短跳转，如：jmp short LABEL\_START，然后加一个nop的空指令来保持3字节的长度。
>
> BPB\_BytsPerSec：每扇区的字节数，类型是双字节长，标准分区上的每扇区字节数一般是512B， FAT12的格式下设置为512\(0x200h\)。
>
> BPB\_SecPerClus：每簇扇区数，偏移13处，类型是字节，簇是数据存储的最小单位，在FAT12格式下一般为1，即每簇只有1个扇区\(512字节\)。
>
> BPB\_RsvdSecCnt：Boot记录占用多少扇区，即在FAT1之前的 引导扇区，一般情况下，引导扇区占用1个扇区。
>
> BPB\_NumFATs：共有多少个FAT表，默认情况下此字段的值为2，也就是有两个FAT表，FAT1和FAT2的内容相同，当FAT1表出错的时候可以使用FAT2来恢复文件分配表。
>
> BPB\_RootEntCnt：根目录文件数最大值，默认为224，每个目录条目占用32B的空间，因此根目录的大小为：224\*32/512=14，即占用14个扇区。
>
> BPB\_TotSec16：扇区总数=0xB40=2880
>
> BPB\_FATSz16：每个FAT占用的扇区数=0x9=9，即FAT1占用1—9逻辑扇区，FAT2占用10—18逻辑扇区。
>
> BPB\_SecPerTrk：每磁道扇区数=0x12=18，即标准FAT12文件系统中，每个磁道的扇区数就是为18。
>
> BPB\_NumHeads：磁头数=0x2=2，该磁盘包括2个磁头，也就是面数是2。
>
> #### 2、FAT表
>
> FAT1和FAT2是两个完全相同的FAT表，每个FAT占用9个扇区。其中FAT1占用1—9扇区，FAT2占用10—18扇区。具体详细介绍看下面4。
>
> #### 3、根目录区
>
> 根目录区的开始扇区号是19，它是由若干个目录条目\(Directory Entry\)组成，条目最多有BPB\_RootEntCnt个，由于根目录区的大小是依赖于BPB\_RootEntCnt的，所以长度不固定。
>
> 在本FAT12中，因为BPB\_RootEntCnt=0xE0=14\*16+0=244，即条目最多为244个，又因为每个条目占用32个字节，故244\*32/512=14，即该根目录区占14个扇区，即19—32。
>
> 根目录区中的每个条目占用32字节，它的格式如下图：
>
> ![](http://hi.csdn.net/attachment/201202/22/0_1329915281Cclw.gif)
>
> 在这里需要注意的是，数据区的第一个簇的簇号是2，而不是0或者1

### 三. 磁头号和起始扇区的计算方法------软盘结构

> 3.4寸1.44M软盘存储结构：
>
> 物理地址                          扇区地址
>
> 0面0磁道  1扇区                       0
>
> 0面0磁道  2扇区                       1
>
> ```
>       ：                                     ：
> ```
>
> 0面0磁道18扇区                      17
>
> 1面0磁道  1扇区                      18
>
> 1面0磁道  2扇区                      19
>
> ```
>       ：                                     ：
> ```
>
> 1面0磁道18扇区                      35

说明：软盘存储地址的编排是以磁道方式安排的，而不是面方式来安排的，即不是排完第一面再排第二面的方式来安排。

为了从扇区号为地址的方式转换为以磁面号、磁道号、起码扇区号为地址方式来从软盘读取文件的方法。换个思考方式，反过来思考，从磁面号、磁道号、起码扇区号为地址转换为以扇区号为地址的方式读取文件。

通过从上面软盘存储结构并使用高中就学到的数学归纳法可得：

**磁面号（F）**=0，**磁道号（R）**=0  **起始扇区号（S）**=18 所对应的**扇区地址 （A）**=17  
  磁面号（F）=1，磁道号（R）=0  起始扇区号（S）=18 所对应的扇区地址 （A）=35

这两个分别为软盘最前面的两个磁道了，通过画下类似于上面的软盘存储结构便可理解。 注 F，R，S，A为简写，比如：F代表磁面号。

进而可以得知任意的 A = F\*18+R\*18\*2+S-1    即  A=（F+2R\)\*18+S-1

所以，A除以18的余数等于 S-1     **S（物理扇区）=A（逻辑扇区）除以18的余数+1**

类似的 A除以18的商等于 F+2R    如何分别得出F，R的值呢？？  已知 F=0或1，2R一定为偶数

即：如果 F+2R为为奇数的话 ，那么肯定F为奇数，F的值只能为1\(F=1\) 所以，**F = A除于18的商 & 1**

对于R，如果 F=0  ，那么 **R=A除以18的商 除以 2 = A除以18的商 &gt;&gt; 1**

如果 F=1 ，那么 A除以18的商 除以 2 = \(F+2R\)/2 = F/2+R  ，又 F/2=0或0.5 由于是整除被舍去  即**R = A除于18的商 &gt;&gt; 1**

## orange's 第五章学习笔记

#### 1.关于chapter5/b的实验

> 对于试验中的最后链接生成的foobar可执行文件（elf格式）用objdump -d foobar反汇编得到代码段汇编代码如下：![](/assets/QQ图片20190506193810.png)然后根据汇编代码对堆栈情况进行分析如下（可能很简陋）：
>
> ![](/assets/QQ图片20190506195728.jpg)

#### 2. chapter5/f实验

2.1 关于头文件为何会\#ifndef   \#endif![](/assets/QQ图片20190509085751.png)2.2 增加了一些对代码的注释，方便大家理解（也可以利用bochs调试理解代码）

#### 3. chapter5/h实验

> 对于头文件：
>
> extern int a;//声明一个全局变量a  
> int a; //定义一个全局变量a  
> extern int a =0 ;//定义一个全局变量a 并给初值。  
> int a =0;//定义一个全局变量a,并给初值，  
> 第四个等于第三个，都是定义一个可以被外部使用的全局变量，并给初值。**                    
> **
>
> 糊涂了吧，他们看上去可真像。但是定义只能出现在一处。也就是说，不管是int a;还是extern int a=0;还是int a=0;都只能出现一次，而那个extern int a可以出现很多次，也就是可以被很多不同.c文件引用而不会出现重复定义
>
> **1、头文件中不要去定义变量，只声明类型即可；这个是在编译，链接的时候解决重复定义问题（多个c文件引用同一个头文件）**
>
> **2、头文件中加入宏处理，保证它不会被重复引用：这个是在编译的时候解决重复定义问题（一个c文件重复包含头文件）**
>
> 把定义看成两种：类型定义，数据定义
>
> 类型定义不分配内存的，比如类的定义，结构体的定义，它是定义一个数据类型而已
>
> 数据定义分配内存，比如类对象定义，变量定义
>
> 不分配内存的，放在头文件（变量的声明（extern int a），函数的声明，结构体的定义）
>
> 分配内存的放在c文件

#### 4. chapter5/i实验

> 1. 注意gcc编译的时候加-fno-stack-protected
> 2. 在proto.h头文件中加disp\_int（）函数的声明
> 3. Makefile的编写注意文件路径
> 4. **若一个.c文件使用了定义在另外一个.c文件的函数或变量（通过头文件中声明这个函数和变量引入），那么在编译的时候，引入其他.c文件中函数或变量的.c文件他的函数名，变量名都只是符号的形式存在在编译后的.o文件中，只有在这两个.c都编译成.o文件后进行链接的时候才会将对应的函数名变成地址，变量也会变成地址**
> 5. 灵活使用bochs进行调试，一般在0x30400设置断点，然后用，s，n进行单步执行，x /32xb 地址进行内容查看，当然也能使用print-stack查看堆栈，u /数字 反汇编多条指令出来从而定位位置设置断点
> 6. 加入了调试过程中遇到的函数地址，变量地址

## orange's 第六章学习笔记

#### 1. chapter6/b实验

> 关于中断处理程序运行在内核态（0特权及），而进程运行在特权及1，由于是时钟中断，不是指令异常（int n）产生的中断，所以不需要检测门描述符的特权及，只需要 cpl &lt; dpl（门描述符所对应选择子所对应gdt中的描述符的dpl） 就行了

#### 2. chapter6/e实验

> 注意bochs运行后为什么会出现  _**A0x0.\#B0x1000.\#A0x1.\#B0x1001.\#\#B0x1002.**_**   **注意这里为什么会出现两个\#，因为TestB\(\)中的delay（\)触发中断后，将打印第一个\#,此时屏幕出现了**  **_**B0x1001.\#**_**  **并且此时esp指向的是进程表a的首地址，接下来进入TestA\(\)中delay（）触发中断的那条指令处，往下执行，所以不会打印任何字符，由于此时的TestA\(\)中的delay（）触发中断不止一次，所以到下一次中断处，进入中断，再打印一个\#，此时屏幕出现了**   **_**B0x1001.\#\#**_**  **同时esp指向了进程表b的首地址，所以中断结束后进入了TestB\(\)，此时是在刚开始执行TestB（）函数的位置，所以屏幕出现了**  **_**B0x1001.\#\#B0x1002.  **_
>
> ![](/assets/未命名文件.png)

## orange's 第七章学习笔记

#### 1. chapter7/k实验

> 这次实验中改变了书中文件console.c中的变量con\_v\_mem\_size = 4000**\(为了让控制台1在显存中的位置位于51行的开头第一个字符,控制台2位于第101行的第一个字符,这样每个控制台就有8000字节可以用，也就是4000个字符可以显示（每个字符2字节）\)**，同时也改变了SCR\_UP和SCR\_DN变量和shift+up shift+down的对应关系**（因为书中对应关系是反的）**



