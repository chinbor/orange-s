# Fifth Chapter

### 一.控制转移

#### 控制转移基本上可分为两大类:同一任务内的控制转移和任务间的控制转移\(任务切换\)。同一任务内的控制转移又可分为:段内转移、特权级不变的段间转移和特权级变换的段间转移。段内转移与实模式下相似,不涉及特权级变换和任务切换。只有段间转移才涉及特权级变换和任务切换。本文介绍保护方式下的控制转移,重点是任务内的特权级变换和任务间的切换。

### &lt;一&gt;任务内无特权级变换的转移

#### 各种段内转移与实模式下相似,当然不涉及特权级变换和任务切换。只有各种形式的段间转移才涉及特权级变换和任务切换。

#### 1.段间转移指令

#### 与实模式下相同,指令 JMP、CALL 和 RET 都具有段间转移的功能,指令 INT 和 IRET 总是段间转移。此外,中断/异常也将引起段间转移。有时把这些具有段间转移功能的指令统称为段间转移指令。在保护模式下,段间转移的目标位置由选择子和偏移构成的地址表示,常把它称为目标地址指针。在 32 位代码段中,上述指针内的偏移使用 32 位表示,这样的指针也称为 48 位全指针。

#### 

与实模式下相似,段间转移指令 JMP 和段间调用指令 CALL 还可分为段间直接转移和段间间接转移两类。如果指令 JMP 和 CALL在指令中直接含有目标地址指针,那么就是段间直接转移;如果指令中含有指向包含目标地址指针的门描述符或 TSS 描述符的指针,那么就是段间间接转移,这种指针只有选择子部分有效,指示调用门、任务门或 TSS 描述符,而偏移部分不起作用。实际上,当段间转移指令 JMP 和段间调用指令 CALL 所含指针的选择子部分指示代码段描述符,那么就是段间直接转移,偏移部分表示目标代码段的入口点;当选择子部分指示门描述符或 TSS 描述符时,就是段间间接转移。

#### 2.向目标代码段转移的步骤

> \(1\)判断目标地址指针内的选择子指示的描述符是否为空描述符。空描述符是 GDT 中的第 0 个描述符,是一个特殊的描述符。目标代码段描述符不能为空描述符,也即选择子的高 14 位不能为 0。
>
> \(2\)从全局或局部描述符表内读出目标代码段描述符。由选择子内的 TI 位,确定使用全局描述符表还是局部描述符表。
>
> \(3\)根据情况,检测描述符类型是否正确;调整 RPL。
>
> \(4\)把目标代码段描述符内的有关内容装载到 CS 高速缓冲寄存器。
>
> \(5\)判断目标地址指针内的偏移是否越出代码段的界限。目标地址指针内的偏移必须不超过目标代码段界限。
>
> \(6\)装载 CS 段寄存器和指令指针寄存器 EIP;CPL 存入 CS 内选择子的 RPL 字段
>
> 上述步骤只是对转移过程的简单说明,实际的动作还要复杂。在把目标代码段描述符内的有关内容转载到 CS 高速缓冲寄存器时,还要进行如下保护检测,其中的 DPL 表示目标代码段描述符的特权级:
>
> \(1\)对于非一致代码段,要求 CPL=DPL,RPL&lt;=DPL;对于一致代码段,要求 CPL&gt;=DPL,rpl不做检测。
>
> \(2\)代码段必须存在,即描述符中的 P 位必须是 1。
>
> 通常描述符特权级 DPL 规定了对应段的特权级。如果描述符描述的是数据段,那么 DPL 就规定了访问该数据段的最外层特权级;
>
> 如果描述符描述的是代码段,那么 DPL 就规定了执行该代码段所需要的 CPL。但从上述装载 CS 高速缓冲寄存器时进行的保护检测可见,对于一致代码段,却要求 CPL&gt;=DPL,也就是说,一致代码段描述符中的 DPL 规定了可以转移到一致代码段的最内层特权级。于是,3级的程序可以转移到任何一致的代码段,而 0 级的程序只允许转移到 DPL 等于 0 的一致代码段。

#### 3.任务内无特权级变换的转移

#### 所谓任务内无特权级变换的转移指:在转移到新的代码段时,当前特权级 CPL 保持不变。利用段间转移指令 JMP、段间调用指令CALL 和段间返回指令 RET 可实现任务内无特权级变换的转移。利用 INT 指令和 IRET 指令也可实现任务内无特权级变换的转移。

#### \(1\)利用段间直接转移指令JMP或CALL

#### 在执行段间转移指令 JMP 时,如果指令内所含指针指示一个代码段,那么就直接开始上述向目标代码段转移的步骤;在执行段间调用指令 CALL 时,如果指令内所含指针指示一个代码段,那么就把返回地址指针压栈,然后就直接开始上述向目标代码段转移的步骤。顺利通过这几步\(不调整 RPL\)后,就完成了任务内无特权级变换的转移。

无论是一致代码段还是非一致代码段，cpl都不会变

#### \(2\)利用段间返回指令RET

#### 在执行段间返回指令 RET 时,如果从堆栈中弹出的目标地址指针指示一个代码段,并且选择子符合 RPL=CPL 的条件,那么就开始上述向目标代码段的转移步骤。顺利通过这几步后,就完成了任务内无特权级变换的转移。

#### 通常情况下,段间返回指令 RET 与段间调用指令 CALL 对应。在利用段间调用指令 CALL 以任务内无特权级变换的方式转移到某个子程序后,在子程序内利用段间返回指令 RET 以任务内无特权级变换的方式返回主程序。由于调用时无特权级变换,所以返回时也无特权级变换,如果真是如此,那么必须能够满足条件 RPL=CPL。

#### \(3\)利用调用门和其它途径

#### 如何利用调用门实行和其它方法实现任务内无特权级变换的转移将在后面的文章中介绍。

#### 4.装载数据段和堆栈段寄存器时的特权检测

#### 上面简单地说明了把选择子装入代码段寄存器 CS 时为实现保护而进行的检测,下面也简单地说明在把选择子装入数据段寄存器和堆栈段寄存器时要进行的检测。

#### 在把选择子装入数据段寄存器 DS、ES、FS 或 GS 时,要进行如下检测:

> \(1\)选择子不能为空;
>
> \(2\)选择子指定的描述符必须是数据段描述符、可读可执行的代码段或一致可读的可执行代码段的描述符;
>
> \(3\)对于数据段和可读可执行代码段,要求 CPL&lt;=DPL,RPL&lt;=DPL;
>
> \(4\)对应的段必须存在。若装入的选择子不满足上述要求,则会产生异常。

#### 在把选择子装入堆栈段寄存器 SS 时要进行如下检测:

> \(1\)选择子不能为空;
>
> \(2\)选择子指定的描述符必须是可读写的数据段描述符;
>
> \(3\)要求 CPL=DPL=RPL;
>
> \(4\)对应段必须存在。若装入的选择子不满足上述条件,则在装入 SS 时就会引起异常。

### 二.任务切换

#### 利用段间转移指令 JMP 或者段间调用指令 CALL,通过任务门或直接通过任务状态段,可以切换到别的任务。此外,在中断/异常或者执行 IRET 指令时也可能发生任务切换。需要注意的是,因为 RET 指令的目标地址只能使用代码段描述符,所以,不能通过 RET指令实现任务切换。

#### 1.直接通过TSS进行任务切换

#### 段间转移指令 JMP 或段间调用指令 CALL 所含指针的选择子指示一个可用任务状态段 TSS 描述符时,正常情况下就发生从当前任务到由该可用 TSS 对应任务\(目标任务\)的切换。目标任务的入口点由目标任务 TSS 内的 CS 和 EIP 字段所规定的指针确定。这样的 JMP或 CALL 指令内的偏移被丢弃。另外,对于段间调用指令 CALL,若目标选择子指示一 TSS 段描述符或任务门时,则返回地址和外层栈指针并不压入堆栈（因为我们之前的用调用门是在任务内的切换所以他会要求接着执行，而这里是任务间的切换，也就是到另一个任务去了）。

#### 处理器采用与访问数据段相同的特权级规则控制对 TSS 段描述符的访问。TSS 段描述符的 DPL 规定了访问该描述符的最外层特权级,只有在相同级别或更内层级别的程序才可以访问它。同时,还要求指示它的选择子的 RPL 必须满足 RPL&lt;=TSS 的 DPL 的条件。当这些条件满足时,就开始任务切换。

#### 2.通过任务门进行任务切换

#### 任务门内的选择子指示某个任务的TSS描述符。当段间转移指令JMP或段间调用指令CALL所含指针的选择子指示一个任务门时,正常情况下就发生任务切换,即从当前任务切换到由任务门内的选择子所指示的 TSS 描述符对应的任务\(目标任务\)。这样的 JMP 或 CALL指令内的偏移被丢弃;任务门内的偏移也无意义。

#### 处理器采用与访问数据段相同的特权级规则控制对任务门的访问。任务门的 DPL 规定了访问该任务门的最外层特权级,只有在同级或更内层级别的程序才可以访问它。同时,还要求指示任务门的选择子 RPL 必须满足 RPL&lt;=任务门的 DPL 的条件。在这些条件满足时,再检查任务门内的选择子,要求该选择子指示 GDT 中的可用的 TSS 描述符。对于任务门所指向的 TSS 描述符的 DPL 不进行特权级检查。检查通过以后,就开始任务切换。



#### 





