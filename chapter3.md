# Third Chapter

#### 07c00h，ffff0h，0100h是什么意思？

> #### FFFF0h与07C00h，这两个都是机器启动后默认访问的内存地址。
>
> #### 首先要知道bios是用来初始化硬件的最底层的软件（然后才是操作系统），因此计算机启动后必须最先被执行。另外我们都知道CPU只能执行内存中的内容的，而一般内存中的数据是易失性的，断电之后内容就会消失。工程师的解决方法是：将存放bios的rom芯片与内存芯片统一编址（不明白的话去看看微机原理与接口的书就明白了）。这样就可以把存放bios的ROM芯片看作是数据永远不会消失不允许被更改的内存了。
>
> #### 开机启动后默认的CS=FFFFh  IP=0000h。这个地址就是bios的地址。这段内存空间很小，所以不能够容下操作系统等大型程序。
>
> #### 相对bios而言操作系统的功能更强大，更新也更快但是也需要更多的空间，通常放在硬盘中。但是如果没有bios的话，那么将会连硬盘都不能使用，又如何启动存放在硬盘中的操作系统呢？正是由于此，机器启动后自动执行bios使其它完成硬件初始化（这样包括硬盘在内的cpu以外的其他硬件设备就可以工作了）。bios完成硬件初始化的任务后，就要把权力移交给操作系统。
>
> #### 工程师进行了强制性的规定：到内存中的07c00h 处寻找系统的引导程序，即CS=0000h IP=7c00h。也就是说任何系统，他的引导程序都必须安排在07c00h开始的地方，否则就不能被正确的引导。当引导程序完成后我们就进入了 Linux Windows等系统了。
>
> #### 书中的代码如果要在DOS下运行，需要把org 07C00h改为org 0100h，这样做的目的是因为在DOS下，装载程序会事先创建一个称为程序段前缀（PSP）256字节的数据区，用来和被装载的程序通信，具体的细节请查验相关资料。而0100h刚好是256个字节的处，这也是代码段开始执行处。

#### A20地址线（就是为了解决某些软件采用地址回绕工作方式）

> #### 地址回绕
>
> #### 早期的8086只有20根地址线，只能访问1M的地址空间。CPU寻址则按段+偏移的方式进行。16位段+16位偏移的可能的范围是 0~0x10FFEF（即0xFFFF0+0xFFFF），即1M+65520字节的范围。由于只有20根地址线，所以在对1M~1M+65520范围进行访问时，会发生“地址回绕”的现象，就是说实际会访问到0~65520的地方。据说某个著名的/臭名昭著的软件利用了这个特点。在80286，386等 CPU上，它会失败，因为这些CPU有多于20根的地址线，并不产生“地址回绕”现象。为了保持完全的兼容性，IBM决定在PC AT系统上加个逻辑，来模仿以上的回绕特征。他们的方法就是把A20和键盘控制器的一个输出进行AND，这样来控制A20的打开和关闭。一开始时A20是被屏蔽的（总为0），直到系统软件去打开它。
>
> #### A20地址线       1981年8月，IBM公司最初推出的个人计算机IBM PC使用的CPU是Intel 8088。在该微机中地址线只有20根\(A0 – A19\)。在当时内存RAM只有几百KB或不到1MB时，20根地址线已足够用来寻址这些内存。其所能寻址的最高地址是0xffff:0xffff，也即 0x10ffef。对于超出0x100000\(1MB\)的寻址地址将默认地环绕到0x0ffef。当IBM公司于1985年引入AT机时，使用的是 Intel 80286 CPU，具有24根地址线，最高可寻址16MB，并且有一个与8088完全兼容的实模式运行方式。然而，在寻址值超过1MB时它却不能象8088那样实现地址寻址的环绕。但是当时已经有一些程序是利用这种地址环绕机制进行工作的。为了实现完全的兼容性，IBM公司发明了使用一个开关来开启或禁止 0x100000地址比特位。由于在当时的8042键盘控制器上恰好有空闲的端口引脚（输出端口P2，引脚P21），于是便使用了该引脚来作为与门控制这个地址比特位。该信号即被称为A20。如果它为零，则比特20及以上地址都被清除。从而实现了兼容性。        由于在机器启动时，默认条件下，A20地址线是禁止的，所以操作系统必须使用适当的方法来开启它。但是由于各种兼容机所使用的芯片集不同，要做到这一点却是非常的麻烦。因此通常要在几种控制方法中选择。
>
> #### 对A20信号线进行控制的常用方法是通过设置键盘控制器的端口值。 有些操作系统将A20的开启和禁止作为实模式与保护运行模式之间进行转换的标准过程中的一部分。       由于键盘的控制器速度很慢，因此就不能使用键盘控制器对A20线来进行操作。为此引进了一个A20快速门选项\(Fast Gate A20\)，它使用I/O端口0x92来处理A20信号线，避免了使用慢速的键盘控制器操作方式。对于不含键盘控制器的系统就只能使用0x92端口来控制，但是该端口也有可能被其它兼容微机上的设备（如显示芯片）所使用，从而造成系统错误的操作。         还有一种方式是通过读0xee端口来开启A20信号线，写该端口则会禁止A20信号线。

#### 一致代码段:

> #### 简单理解，就是操作系统拿出来被共享的代码段,可以被低特权级的用户直接调用访问的代码.通常这些共享代码，是"不访问"受保护的资源和某些类型异常处理。比如一些数学计算函数库,为纯粹的数学运算计算,被作为一致代码段.
>
> #### 1.特权级高的程序不允许访问特权级低的数据:核心态不允许调用用户态的数据.
>
> #### 2.特权级低的程序可以访问到特权级高的数据.但是特权级不会改变:用户态还是用户态.

#### 非一致代码段:

> #### 为了避免低特权级的访问而被操作系统保护起来的系统代码.
>
> #### 1.只允许同级间访问.
>
> #### 2.绝对禁止不同级访问:核心态不用用户态.用户态也不使用核心态.

#### cpl，dpl，rpl（注意数字越大，特权级越小）

> #### **CPL**是当前进程的权限级别\(**Current Privilege Level**\)，是当前正在执行的代码所在的段的特权级，存在于cs寄存器的低两位。
>
> #### **RPL**说明的是进程对段访问的请求权限\(**Request Privilege Level**\)，是对于段选择子而言的，每个段选择子有自己的RPL，它说明的是进程对段访问的请求权限，有点像函数参数。
>
> #### **DPL**存储在段描述符中，规定访问该段的权限级别\(**Descriptor Privilege Level**\)，每个段的DPL固定。当进程访问一个段时，需要进程特权级检查，一般要求**DPL &gt;= max {CPL, RPL}**
>
> #### **为什么采用RPL，是考虑到安全的问题，就好像你明明对一个文件用有写权限，为什么用只读打开它呢，还不是为了安全！**
>
> #### 举个例子：
>
> #### **中国官员分为6级国家主席1、总理2、省长3、市长4、县长5、乡长6，假设我是当前进程，级别总理（CPL=2）,我去南城市\(DPL=4\)考察,用省长的级别\(RPL=3 这样也能吓死他们:-\)\)去访问,可以吧，如果用县长的级别，人家就不理咱了\(你看看电视上的微服私访\).**

#### **代码间跳转**

> ##### **普通转跳（没有经过Gate 这东西）：**即JMP或Call后跟着48位全指针（16位段选择子+32位地址偏移），且其中的段选择子指向代码段描述符，这样的跳转称为直接（普通）跳转。**普通跳转不能使特权级发生跃迁，即不会引起CPL的变化**，看下面的详细描述：
>
> ##### 目标是一致代码段：
>
> ##### 要求：CPL &gt;= DPL ，RPL不检查。**转跳后程序的CPL = 转跳前程序的CPL**
>
> ##### **目标是非一致代码段：**
>
> ##### **要求：CPL = DPL　AND  RPL&lt;= DPL。转跳后程序的CPL = 转跳前程序的CPL**
>
> ##### 通过调用门的跳转：当段间转移指令JMP和段间转移指令CALL后跟着的目标段选择子指向一个调用门描述符时，该跳转就是利用调用门的跳转。这时如果选择子后跟着32位的地址偏移，也不会被cpu使用，因为调用门描述符已经记录了目标代码的偏移。使用调门进行的跳转比普通跳转多一个步骤，即在访问调用门描述符时要将描述符当作一个数据段来检查访问权限，要求指示调用门的选择子的 RPL≤门描述符DPL，同时当前代码段CPL≤门描述符DPL，就如同访问数据段一样，要求访问数据段的程序的CPL≤待访问的数据段的DPL，同时选择子的RPL≤待访问的数据段或堆栈段的DPL。只有满足了以上条件，CPU才会进一步从调用门描述符中读取目标代码段的选择子和地址偏移，进行下一步的操作。
>
> ##### 从调用门中读取到目标代码的段选择子和地址偏移后，我们当前掌握的信息又回到了先前，和普通跳转站在了同一条起跑线上（普通跳转一开始就得到了目标代码的段选择子和地址偏移），有所不同的是，此时，CPU会将读到的目标代码段选择子中的RPL清0，即忽略了调用门中代码段选择子的RPL的作用。完成这一步后，CPU开始对当前程序的CPL，目标代码段选择子的RPL（事实上它被清0后总能满足要求）以及由目标代码选择子指示的目标代码段描述符中的DPL进行特权级检查，并根据情况进行跳转，具体情况如下：
>
> **目标是一致代码段：**
>
> ##### 要求：**CPL &gt;= DPL ，RPL不检查，因为RPL被清0，所以事实上永远满足RPL &lt;= DPL，这一点与普通跳转一致，适用于JMP和CALL。转跳后程序的CPL = 转跳前程序的CPL，因此特权级没有发生跃迁。**
>
> **目标是非一致代码段：**
>
> ##### 当用jmp指令跳转：
>
> ##### **要求：CPL = DPL　（RPL被清0，不检查），若不满足要求则程序引起异常。转跳后程序的CPL = DPL（**因为前提是CPL=DPL，所以转跳后程序的CPL = DPL不会改变CPL的值，特权级也没有发生变化。如果访问时不满足前提CPL=DPL，则引发异常。）
>
> ##### 当用call指令跳转：
>
> ##### **要求：CPL &gt;= DPL（RPL被清0，不检查），若不满足要求则程序引起异常。  转跳后程序的CPL = DPL。（**当条件CPL=DPL时，程序跳转后CPL=DPL,特权级不发生跃迁；当CPL＞DPL时，程序跳转后CPL=DPL,特权级发生跃迁，这是我们当目前位置唯一见到的使程序当前执行优先级\(CPL\)发生变化的跳转方法，即用CALL指令+调用门方式跳转，且目标代码段是非一致代码段。）

#### 为什么全局描述符表GDT的第0项总是一个空描述符

> ##### 用于当一个任务使用的所有段都是系统全局段时。
>
> ##### GDTR（48位）用于描述GDT的基址和界限
>
> ##### LDTR（16位）用于描述当前任务的LDT在GDT中的选择子。
>
> ##### 如果一个任务没有LDT，就会把LDTR清空，此时指向GDT中的第0项描述符，即为空描述符。

#### align 32

> ##### 代表的意思就是32字节对齐，也地址就是能够整除32

#### 保护模式切换到实模式相关说明（注意一个问题，那就是不能通过mov cs，123来为cs寄存器赋值）

> #### 保护模式下的段描述符高速缓冲寄存器![](https://img-blog.csdn.net/20150312192751536)各段描述符高速缓冲寄存器之内容如表所示。其中,32 位段基地址直接取自描述符, 32 位的段界限取自描述符中 20 位的段界限,并根据描述符属性中的粒度位转换成以字节为单位。其它十个特性根据描述符中的属性而定,“Y”表示“是”,“N”表示“否” ,“R”表示必须可读,“W”表示必须可写,“P”表示必须存在,“D”表示根据描述符中属性而定。
>
> #### 实模式下的段描述符高速缓冲寄存器
>
> #### ![](/assets/QQ图片20190413153805.png)段基地址仍是32位，其值是相应段寄存器值\(段值\)乘以16，在把段值装载到段寄存器时刷新。由于其值是16位段值乘上16，所以在实模式下基地址实际上有效位只有20位（最高的20位）。每个段的32位段界限都固定为0FFFFH，段属性的许多位也是固定的。所谓固定是指在实方式下不可设置这些属性值，只能继续沿用保护方式下所设置的值。因此，在准备结束保护模式回到实模式之前，**要通过加载一个合适的描述符选择子（如实例代码中的Normal选择子）到有关段寄存器，以使得对应段描述符高速缓冲寄存器中含有合适的段界限和属性。**必须在保护模式下设置好段高速缓冲寄存器的值，因为一旦到了实模式下就不能在改变了。

#### 关于orange's书中的sudo mount -o loop pm.img /mnt/floppy不成功的解决办法（pm.img未初始化）

> 1.使用 losetup 命令，将 pm.img 作为 loop device 使用：
>
> ```
> sudo losetup /dev/loop0 pm.img
> ```
>
> 2.然后，格式化这个 loop device：
>
> ```
> sudo mkfs.msdos /dev/loop0
> ```
>
> 3.检查文件系统：
>
> ```
> sudo fsck.msdos /dev/loop0
> ```
>
> 4.删除 loop device：
>
> ```
> sudo losetup -d /dev/loop0
> ```
>
> 这时候，pm.img 已经格式化完成，可以作为一个软盘镜像使用。用file查看，结果为：
>
> ```
> pm.img: DOS floppy 1440k, x86 hard disk boot sector
> ```
>
> 再次输入
>
> ```
> sudo mount -o loop pm.img /mnt/floppy
> ```

#### 关于bochs中如何调试orange‘s 中chapter3的代码：

> ##### 在你的程序 LABEL\_BEGIN后面紧接着写一个jmp $（让代码死循环在这个位置），然后编译为com文件。写入虚拟软盘。
>
> ##### 之后启动调试模式的bochs，先不要设置任何断点，直接执行到dos界面。然后在dos中运行你的程序，出现假死状态（必然的，程序一开始就会死循环）。
>
> ##### 然后切换到bochs的命令行窗口，估计需要先按ctrl+c,然后输入r命令，察看当前eip寄存器的值。例如当前值为0x124,那么就输入下面的命令，set $eip=0x126,就是让EIP增大2即可，JMP $的机器码要占这么个大小。
>
> ##### 之后，就可以单步跟踪执行了
>
> ##### 在bochs的控制台下
>
> ##### r：可以看一些基本寄存器内容
>
> ##### c：执行到断点处
>
> ##### b 地址：设置断点
>
> ##### x /nuf 地址：可以查看线性地址空间地址内容 ，n 显示的单元数，u 每个显示单元的大小（可以是b\(byte\),h\(word\),w\(dword\),g\(dword64\)）,f显示格式，f可以是\(x\(16\),d\(10\),o\(8\),t\(2\)\)
>
> ##### xp /nuf 地址：查看物理地址空间内容
>
> ##### sreg：可以查看段寄存器
>
> ##### n：单步执行不进入函数
>
> ##### s：单步执行进入函数
>
> ##### creg：可以查看cr寄存器
>
> ##### u start end：反汇编一段内存中的机器码（对于知道地址但是不知道具体汇编指令很有用）

#### **Address Range Descriptor Structure：（地址范围描述符结构）**

> ![](/assets/QQ图片20190416133103.png)其中Type的取值及其意义如下:![](/assets/QQ图片20190416133110.png)如下一些原因造成BIOS将某个内存段标记为AddressRangeReserved:
>
> * 这个地址范围包含着系统ROM；
>
> * 这个地址范围包含着被ROM使用的RAM；
> * 这个地址范围被用作系统设备内存映射；
> * 这个地址范围由于某种原因,不适合被标准设备用作设备内存空间。
>
> ARDS 中的BaseAddr为由BaseAddrLow和BaseAddrHigh组成的64位地址，长度也为LengthLow和LengthHigh两个32位数据组成的64位长度，在使用中好像高32位并没有用到，为零。Type取值为16进制。查看内存容量使用INT 15h ，将描述最后一个可用的内存段的ARDS中的BaseAddrLow+LengthLow即可得到内存容量，据此进行内存的分页。



