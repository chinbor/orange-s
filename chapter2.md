# Second Chapter

## 一.存储段描述符

#### 用于表示上述定义段的三个参数的数据结构称为描述符。每个描述符长8个字节。在保护方式下,每一个段都有一个相应的描述符来描述。

#### 1.存储段描述符的格式

#### 存储段是存放可由程序直接进行访问的代码和数据的段。存储段描述符描述存储段,所以存储段描述符也被称为代码和数据段描述符。存储段描述符的格式如下表所示。表中上面一排是对描述符8个字节的使用的说明,最低地址字节\(假设地址为m\)在最右边,其余字节依次向左,直到最高字节\(地址为m+7\)。下一排是对属性域各位的说明。

#### ![](https://img-blog.csdn.net/20150312192201306)![](https://img-blog.csdn.net/20150312192342217)从上表可知,长 32 位的段基地址\(段开始地址\)被安排在描述符的两个域中,其位 0—位 23 安排在描述符内的第 2—第 4 字节中,其位 24—位 31 被安排在描述符内的第 7 字节中。长 20 位的段界限也被安排在描述符的两个域中,其位 0—位 15 被安排在描述符内的第 0—第 1 字节中,其位 16—位 19 被安排在描述符内的第 6 字节的低 4 位中。

#### 80386 描述符中的段属性也被安排在两个域中。下面对其定义及意义作说明。

* #### P 位称为存在\(Present\)位。P=1 表示描述符对地址转换是有效的,或者说该描述符所描述的段存在,即在内存中;P=0 表示描述符对地址转换无效,即该段不存在。使用该描述符进行内存访问时会引起异常。
* #### DPL 表示描述符特权级\(Descriptor Privilege level\),共 2 位。它规定了所描述段的特权级,用于特权检查,以决定对该段能否访问。
* #### DT 位说明描述符的类型。对于存储段描述符而言,DT=1,以区别与系统段描述符和门描述符\(DT=0\)。
* #### TYPE 说明存储段描述符所描述的存储段的具体属性。其中的位 0 指示描述符是否被访问过\(Accessed\),用符号 A 标记。A=0 表示尚未被访问,A=1 表示段已被访问。当把描述符的相应选择子装入到段寄存器时,80386 把该位置为 1,表明描述符已被访问。操作系统可测试访问位,已确定描述符是否被访问过。其中的位 3 指示所描述的段是代码段还是数据段,用符号 E 标记。E=0 表示段为数据段,相应的描述符也就是数据段\(包括堆栈段\)描述符。数据段是不可执行的,但总是可读的。 E=1 表示段是可执行段,即代码段,相应的描述符就是代码段描述符。代码段总是不可写的,若需要对代码段进行写入操作,则必须使用别名技术,即用一个可写的数据段描述符来描述该代码段,然后对此数据段进行写入。在数据段描述符中\(E=0 的情况\),TYPE 中的位 1 指示所描述的数据段是否可写,用 W 标记。 W=0 表示对应的数据段不可写。反之,W=1 表示数据段是可写的。注意,数据段总是可读的。TYPE 中的位 2 是 ED 位,指示所描述的数据段的扩展方向。ED=0 表示数据段向高端扩展,也即段内偏移必须小于等于段界限。ED=1 表示数据段向低扩展,段内偏移必须大于段界限。

  #### 在代码段描述符中\(E=1 的情况\),TYPE 中的位 1 指示所描述的代码段是否可读,用符号 R 标记。R=0 表示对应的代码段不可读,只能执行。R=1 表示对应的代码段可读可执行。注意代码段总是不可写的,若需要对代码段进行写入操作,则必须使用别名技术。在代码段中,TYPE 中的位 2 指示所描述的代码段是否是一致代码段,用 C 标记。C=0 表示对应的代码段不是一致代码段\(普通代码段\),C=1表示对应的代码段是一致代码段。
* #### G 位就是段界限粒度\(Granularity\)位。G=0 表示界限粒度为字节;G=1 表示界限粒度为 4K 字节。注意,界限粒度只对段界限有效,对段基地址无效,段基地址总是以字节为单位。
* #### D 位是一个很特殊的位,在描述可执行段、向下扩展数据段或由 SS 寄存器寻址的段\(通常是堆栈段\)的三种描述符中的意义各不相同。

  #### 在描述可执行段的描述符中,D 位决定了指令使用的地址及操作数所默认的大小。D=1 表示默认情况下指令使用 32 位地址及 32 位或 8 位操作数,这样的代码段也称为 32 位代码段;D=0 表示默认情况下,使用 16 位地址及 16 位或 8 位操作数,这样的代码段也称为16 位代码段,它与 80286 兼容。可以使用地址大小前缀和操作数大小前缀分别改变默认的地址或操作数的大小。

  #### 在向下扩展数据段的描述符中,D 位决定段的上部边界。D=1 表示段的上部界限为 4G;D=0 表示段的上部界限为 64K,这是为了与 80286 兼容。

  #### 在描述由 SS 寄存器寻址的段描述符中,D 位决定隐式的堆栈访问指令\(如 PUSH 和 POP 指令\)使用何种堆栈指针寄存器。D=1 表示使用 32 位堆栈指针寄存器 ESP;D=0 表示使用 16 位堆栈指针寄存器 SP,这与 80286 兼容。
* #### AVL 位是软件可利用位。80386 对该位的使用未做规定,Intel 公司也保证今后开发生产的处理器只要与 80386 兼容,就不会对该位的使用做任何定义或规定。此外,描述符内第 6 字节中的位 5 必须置为 0,可以理解成是为以后的处理器保留的。

#### 2.存储段描述符的结构类型表示

```
DESC STRUC

         LIMITL             DW    0     ;段界限低 16 位

         BASEL              DW     0     ;基地址低 16 位

         BASEM             DB     0     ;基地址中间 8 位

         ATTRIBUTES  DW     0     ;段属性(含段界限的高4位)

         BASEH             DB     0     ;基地址的高 8 位

DESC ENDS

共8个字节
```

* #### 全局和局部描述符表\(在整个系统中,全局描述符表 GDT 和中断描述符表 IDT 只有一张,局部描述符表可以有若干张,每个任务可以有一张。\)

> ##### 每个描述符表本身形成一个特殊的数据段。这样的特殊数据段最多可包含有 8K\(8192\)个描述符.

#### a\)全局描述符表 GDT

> ##### 全局描述符表 GDT 含有每一个任务都可能或可以访问的段的描述符,通常包含描述操作系统所使用的代码段、数据段和堆栈段的描述符,也包含多种特殊数据段描述符,如各个用于描述任务 LDT 的特殊数据段等。

#### b\)局部描述符表 LDT

> ##### 每个任务的局部描述符表 LDT 含有该任务自己的代码段、数据段和堆栈段的描述 符,也        包含该任务所使用的一些门描述符,随着任务的切换,系统当前的局部描述符表 LDT 也随之切换

#### 在任务切换时,并不切换 GDT。通过 LDT 可以使各个任务私有的各个段与其它任务相隔离,从而达到受保护的目的。通过 GDT 可以使各任务都需要使用的段能够被共享。

> ##### 一个任务可使用的整个虚拟地址空间分为相等的两半，一半的空间的描述符在全局描述符表中,另一半空间的描述符在局部描述符表中。由于全局和局部描述符表都可以包含多达 8192 个描述符,而每个描述符所描述的段的最大值可达 4G 字节,因此最大的虚拟地址空间可为:4GB\*8192\*2=64MMB=64TB

* #### 段选择子

#### 在实模式下,逻辑地址空间中存储单元的地址由段值和段内偏移两部分组成。在保护方式下,虚拟地址空间\(相当于逻辑地址空间\)中存储单元的地址由段选择子和段内偏移两部分组成。

#### 段选择子长 16 位,其格式如下表所示。从表中可见,段选择子的高 13 位是描述符索引\(Index\)。所谓描述符索引是指描述符在描述符表中的序号。段选择子的第 2 位是引用描述符表指示位,标记为 TI\(Table Indicator\),TI=0 指示从全局描述符表 GDT 中读取描述符;TI=1 指示从局部描述符表 LDT 中读取描述符。选择子的最低两位是请求特权级 RPL\(Requested Privilege Level\),用于特权检查.每当程序试图访问一个段时，要把当前特权级cpl与所访问段的特权级dpl进行比较,以确定是否允许程序对该段的访问。使用选择子的RPL 字段,将改变特权级的测试规则。在这种情况下,与所访问段的特权级比较的特权级不是 CPL,而是 CPU 与 RPL 中更外层的特权级。 CPL 存放在 CS 寄存器的 RPL 字段内,每当一个代码段选择子装入 CS 寄存器中时,处理器自动地把 CPL 存放到 CS 的 RPL 字段。由于选择子中的描述符索引字段用 13 位表示,所以可区分 8192 个描述符。这也就是描述符表最多包含 8192 个描述符的原因。由于每个描述符长 8 字节,根据上表所示选择子的格式,屏蔽选择子低 3 位后所得的值就是选择子所指定的描述符在描述符表中的偏移,这可认为是安排选择子高 13 位作为描述符索引的原因。

#### 有一个特殊的选择子称为空\(Null\)选择子,它的 Index=0,TI=0,而 RPL 字段可以为任意值。空选择子有特定的用途,当用空选择子进行存储访问时会引起异常。空选择子是特别定义的,它不对应于全局描述符表 GDT 中的第 0 个描述符,因此处理器中的第 0 个描述符总不被处理器访问,一般把它置成全 0。但当 TI=1 时,Index 为 0 的选择子不是空选择子,它指定了当前任务局部描述符表 LDT 中的第 0 个描述符。

#### ![](https://img-blog.csdn.net/20150312192725095)选择子确定描述符,描述符确定段基地址,段基地址与偏移之和就是线性地址。

* #### 段描述符高速缓冲寄存器

#### 在实模式下,段寄存器含有段值,为访问存储器形成物理地址时,处理器引用相应的某个段寄存器并将其值乘以 16,形成 20 位的段基地址。在保护模式下,段寄存器含有段选择子,如上所述,为了访问存储器形成线性地址时,处理器要使用选择子所指定的描述符中的基地址等信息。为了避免在每次存储器访问时,都要访问描述符表而获得对应的段描述符,从 80286 开始每个段寄存器都配有一个高速缓冲寄存器,称之为段描述符高速缓冲寄存器或描述符投影寄存器,对程序员而言它是不可见的。每当把一个选择子装入到某个段寄存器时,处理器自动从描述符表中取出相应的描述符,把描述符中的信息保存到对应的高速缓冲寄存器中。此后对该段访问时,处理器都使用对应高速缓冲寄存器中的描述符信息,而不用再从描述符表中取描述符。

#### 3.控制寄存器和系统地址寄存器

* #### 控制寄存器![](https://img-blog.csdn.net/20150312192944886)从上表可见,80386 有四个 32 位的控制寄存器,分别命名位 CR0、CR1、CR2 和 CR3。但 CR1 被保留,供今后开发的处理器使用,在 80386 中不能使用 CR1,否则会引起无效指令操作异常。CR0 包括指示处理器工作方式的控制位,包含启用和禁止分页管理机制的控制位,包含控制浮点协处理器操作的控制位。CR2 及 CR3 由分页管理机制使用。CR0 中的位 5—位 30 及 CR3 中的位 0 至位 11 是保留位,这些位不能是随意值,必须为 0。控制寄存器 CR0 的低 16 位等同于 80286 的机器状态字 MSW。

#### a.保护控制位

#### 控制寄存器 CR0 中的位 0 用 PE 标记,位 31 用 PG 标记,这两个位控制分段和分页管理机制的操作,所以把它们称为保护控制位。PE 控制分段管理机制。PE=0,处理器运行于实模式;PE=1,处理器运行于保护方式。PG 控制分页管理机制。PG=0,禁用分页管理机制,此时分段管理机制产生的线性地址直接作为物理地址使用;PG=1,启用分页管理机制,此时线性地址经分页管理机制转换位物理地址。

#### ![](https://img-blog.csdn.net/20150312193053776)由于只有在保护方式下才可启用分页机制,所以尽管两个位分别为 0 和 1共可以有四种组合,但只有三种组合方式有效。PE=0 且 PG=1 是无效组合,因此,用 PG 为 1 且 PE 为 0 的值装入 CR0 寄存器将引起通用保护异常。

#### b.协处理器控制位

#### 控制寄存器 CR0 中的位 1—位 4 分别标记为 MP\(算术存在位\)、EM\(模拟位\)、TS\(任务切换位\) 和 ET\(扩展类型位\),它们控制浮点协处理器的操作。

#### c.CR2和CR3

#### 控制寄存器 CR2 和 CR3 由分页管理机制使用。CR2 用于发生页异常时报告出错信息。当发生页异常时,处理器把引起页异常的线性地址保存在 CR2 中。操作系统中的页异常处理程序可以检查 CR2 的内容,从而查出线性地址空间中的哪一页引起本次异常。CR3 用于保存页目录表的起始物理地址.

* #### 系统地址寄存器

#### 全局描述符表 GDT、局部描述符表 LDT 和中断描述符表 IDT 等都是保护方式下非常重要的特殊段,它们包含有为段机制所用的重要表格。为了方便快速地定位这些段,处理器采用一些特殊的寄存器保存这些段的基地址和段界限。我们把这些特殊的寄存器称为系统地址寄存器。

#### a.全局描述符表寄存器GDTR![](https://img-blog.csdn.net/20150312192839695)GDTR 中的段界限以字节为单位。由于段选择子中只有 13 位作为描述符索引,而每个描述符长 8 个字节,所以用 16 位的界限足够。通常,对于含有 N 个描述符的描述符表的段界限设为 8\*N-1。

#### b.局部描述符表寄存器 LDTR![](https://img-blog.csdn.net/20150312192852129)局部描述符表寄存器 LDTR 规定当前任务使用的局部描述符表 LDT。如本文开始处的表格所示,LDTR 类似于段寄存器,由程序员可见的 16 位的寄存器和程序员不可见的高速缓冲寄存器组成。实际上,每个任务的局部描述符表 LDT 作为系统的一个特殊段,由一个描述符描述。而用于描述符 LDT 的描述符存放在 GDT 中。在初始化或任务切换过程中,把描述符对应任务 LDT 的描述符的选择子装入LDTR,处理器根据装入 LDTR 可见部分的选择子,从 GDT 中取出对应的描述符,并把 LDT 的基地址、界限和属性等信息保存到 LDTR的不可见的高速缓冲寄存器中。随后对 LDT 的访问,就可根据保存在高速缓冲寄存器中的有关信息进行合法性检查。LDTR 寄存器包含当前任务的 LDT 的选择子。所以,装入到 LDTR 的选择子必须确定一个位于 GDT 中的类型为 LDT 的系统段描述符,也即选择子中的 TI 位必须是 0,而且描述符中的类型字段所表示的类型必须为 LDT。可以用一个空选择子装入 LDTR,这表示当前任务没有 LDT。在这种情况下,所有装入到段寄存器的选择子都必须指示 GDT 中的描述符,也即当前任务涉及的段均由 GDT 中的描述符来描述。如果再把一个 TI 位为 1 的选择子装入到段寄存器,将引起异常。

#### c.中断描述符表寄存器 IDTR

#### 中断描述符表寄存器 IDTR 指向中断描述符表 IDT。如本文开始处的表格所示,IDTR 长 48 位,其中 32 位的基地址规定 IDT 的基地址,16 位的界限规定 IDT 的段界限。由于 80386 只支持 256 个中断/异常,所以 IDT 表最大长度是 2K\(一个中断8字节\),以字节位单位的段界限为 7FFH。IDTR 指示 IDT 的方式与 GDTR 指示 GDT 的方式相同。

#### d.任务状态段寄存器 TR

#### 任务状态段寄存器 TR 包含指示描述当前任务的任务状态段的描述符选择子,从而规定了当前任务的状态段。如本文开始处的表格所示,TR 也有程序员可见和不可见两部分。当把任务状态段的选择子装入到 TR 可见部分时,处理器自动把选择子所索引的描述符中的段基地址等信息保存到不可见的高速缓冲寄存器中。在此之后,对当前任务状态段的访问可快速方便地进行。装入到 TR 的选择子不能为空,必须索引位于 GDT 中的描述符,且描述符的类型必须是 TSS。

#### 

#### 本文内容转自csdn博客，原文地址

#### [https://blog.csdn.net/u014634338/article/details/44225841](https://blog.csdn.net/u014634338/article/details/44225841)



